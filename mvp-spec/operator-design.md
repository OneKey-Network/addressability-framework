# Operator Design

‚ö†Ô∏è To **view diagrams** in this page, you are invited to install a browser extension such as [mermaid-diagrams](https://chrome.google.com/webstore/detail/mermaid-diagrams/phfcghedmopjadpojhmmaffjmfiakfil)

## Context

Operators are contracting parties responsible for storing and controlling access to users data, in a secured way.

In this context,

- **data** means:
  - **Prebid ID** is the pseudonymous identifier _generated by an operator_ to identify a device
    - Other optional IDs will be supported in the future but are **not** part of the MVP
  - **Preferences** are user-set preferences regarding online tracking that is _captured by a CMP UI_ or a website (
    such as a publisher).
    - In the MVP, only one "preference" is supported: optin status.
- **storing** means in the form of **cookies** stored on Prebid SSO top level domain +1 (TLD+1, ex: `prebidsso.com`)
- **controlling access** means to offer ways for contracting parties to read and write this data and help them store a
  copy ("cache") of these cookies on their own domain.
- ***in a secured way*** has different meanings that are discussed below

Multiple operators will implement the same set of core features under the same TLD+1, although at this stage it is not
clear how they will co-operate.

## Example workflows

We represent two typical workflows:

- the first interaction with Prebid where a user visits a publisher's page, that triggers a CMP
- a visit to a advertiser while the user already opted in to Prebid

...in two different contexts:

- where the browser supports third party cookies (3PC)
- where it doesn't

### With 3PC

When 3d party cookies are available, all calls to read cookies can be made via Javascript to read or write data.

- When visiting a publisher and meeting Prebid SSO for the first time:
  - the publisher's page is called.
  - the publisher's backend serves the requested page, and it includes a JS library that checks for existence of
    Prebid SSO cookie
  - a JS call to the operator to "read or init" data will generate a new ID
  - the ID can be displayed in the CMP UI
  - when the user submits their preferences:
    - a JS call is made to the CMP to "prepare" the values to write (more about this, below)
    - another JS call is made to the operator to write these values (saved under Prebid SSO domain)
    - finally, these values are saved on the publisher's domain
- When a participating user visits an advertiser:
  - a JS call is made to the operator to get the Prebid SSO ID and preferences
  - the values are saved on the advertiser's domain

‚ÑπÔ∏è in this scenario, no full page redirect is needed

```mermaid
sequenceDiagram
participant U as user
participant B as browser
participant P as publisher P http server
participant C as CMP http server
participant A as advertiser A http server
participant O as operator node O

rect rgba(224, 224, 224, .55)
    note right of U: Time T1<br>"WRITE" scenario: user visits publisher<br>and sets their preferences for the first time
    U ->> B: visit www.publisherP.com/pageP.html
    activate U

        activate B
            B ->> P: GET /pageP.html
        deactivate B

        activate P
            P -->> B: pageP.html with embedded CMP
        deactivate P

        activate B
            B ->> B: no Prebid SSO ID üç™ found
            B ->> O: JS call "read or init" endpoint

            activate O
                note over B,O: make sure this URL cannot be "replayed" by hackers to read central cookies
                note over O: make sure<br/>CMP is authorized to read
                O ->> O: create ID
                O -->> B: Prebid SSO ID
            deactivate O

            B ->> B: show Prebid SSO ID

            B --> U: 
        deactivate B

    deactivate U

    U ->> B: submit preferences
    activate U

        activate B
            B ->> C: JS call: "package" preferences value

            activate C
                C -->> B: packaged preferences
            deactivate C

            B ->> O: JS call "write" endpoint<br>id = xxx<br>preferences = yyy

            activate O
                note over B,O: make sure this URL cannot be "replayed" by hackers to write central cookies
                note over O: make sure<br/>CMP is authorized to read and write
                note over O: make sure<br/>ID and preferences values can be trusted
                O ->> O: write 1P üç™:<br/>ID & preferences
                O -->> B: id & preferences
            deactivate O

            B ->> B: write 1P üç™<br/>ID & preferences

            B -->> U: 

        deactivate B    

    deactivate U
end

rect rgba(255, 255, 255, .55)
    note right of U: Time T2<br>"READ" scenario: user visits a "new" advertiser without CMP

    U ->> B: visit www.advertiserA.com/pageA.html
    activate U

        activate B
            B ->> A: GET /pageA.html
        deactivate B

        activate A
            A -->> B: display pageA.html
        deactivate A

        activate B

            B ->> B: no Prebid SSO ID üç™ found
            B ->> O: JS call "read" endpoint

            activate O
                note over B,O: make sure this URL cannot be "replayed" by hackers to read data
                O ->> O: read 1P üç™
                note over O: make sure<br/>advertiserA is authorized to read
                O -->> B: id & preferences
            deactivate O

            B ->> B: write 1P üç™

            B -->> U: 
        deactivate B

    deactivate U
end
```

### Without 3PC

Without 3d party cookies,

- **a full page load** on Prebid SSO domain is needed to read or write cookies stored on Prebid SSO TLD+1
- **a full page load** on the website domain is needed to write cookies based on values read from Prebid SSO

So the only way to interact with Prebid SSO cookies is through  **full page "redirects"**.

- When visiting a publisher and meeting Prebid SSO for the first time:
  - the publisher's page is called. Here,  **two options are possible**:
    - either the publisher's _backend_ checks the existence of Prebid SSO cookie, and redirect the user to Prebid
      SSO operator
    - or, the publisher's backend serves the requested page, and it includes a JS library that does exactly the same
      thing
  - in both cases the browser is  **redirected**  to Prebid SSO operator to read any existing cookie or to create an
    ID if needed
  - the operator  **redirects**  back to the original page, this time with a Prebid SSO ID as part of the URL
  - the CMP is displayed
  - the ID can be displayed in the CMP UI if needed
  - when the user submits their preferences:
    - a JS call is made to the CMP to "prepare" the values to write
    - via JS, a  **redirect**  is triggered to the operator to write these values (saved under Prebid SSO domain)
    - the operator  **redirects**  back to the original page, this time with a Prebid SSO ID & preferences as part
      of the URL
    - finally, these values are saved as cookies on the publisher's domain
      - Note that this, again, can be done on the publisher's backend side or via JS
- When a participating user visits an advertiser:
  - on the advertiser backend, a  **redirect**  is triggered to the operator to get the Prebid SSO ID and preferences
  - the operator  **redirects**  back to the original page, this time with a Prebid SSO ID & preferences as part of
    the URL
  - the values are saved on the advertiser's domain

```mermaid
sequenceDiagram
participant U as user
participant B as browser
participant P as publisher P http server
participant C as CMP http server
participant A as advertiser A http server
participant O as operator node O

rect rgba(224, 224, 224, .55)
    note right of U: Time T1<br>"WRITE" scenario: user visits publisher<br>and sets their preferences for the first time

    U ->> B: visit www.publisherP.com/pageP.html
    activate U

        activate B
            B ->> P: GET /pageP.html
        deactivate B

        activate P
            P -->> B: embed CMP
        deactivate P

        activate B
            B ->> B: no Prebid SSO ID üç™ found
            B -->> B: REDIRECT
            B ->> O: call "read or init" endpoint<br/>redirectUrl = publisherP.com/pageP.html
        deactivate B

        activate O
            note over B,O: make sure this URL cannot be "replayed" by hackers to read central cookies
            note over O: make sure<br/>CMP is authorized to read
            O ->> O: create ID
            O -->> B: REDIRECT
        deactivate O

        activate B
            B ->> P: GET /pageP.html?id=xxx
        deactivate B

        activate P
            P -->> B: embed CMP
        deactivate P

        activate B
            B ->> B: show Prebid SSO ID
            B -->> U:  
        deactivate B

    deactivate U

    U ->> B: submit preferences

    activate U

        activate B
            B ->> C: JS call to sign preferences value
            activate C
                C -->> B: url to call = ...
            deactivate C

            B -->> B: REDIRECT
            B ->> O: call "write" endpoint<br>id = xxx<br>preferences = yyy<br>redirectUrl = publisherP.com/pageP.html
        deactivate B

        activate O
            note over B,O: make sure this URL cannot be "replayed" by hackers to write central cookies
            note over O: make sure<br/>CMP is authorized to read and write
            note over O: make sure<br/>ID and preferences values can be trusted
            O ->> O: write 1P üç™:<br/>ID & preferences
            O -->> B: REDIRECT
        deactivate O

        activate B
            B ->> P: GET /pageP.html?<br/>cookie = ID & preferences
        deactivate B

        activate P
            note over B,P: make sure this URL cannot be "replayed" by hackers<br>to write local cookies
            note over B,P: make sure ID & preferences in the URL<br/>cannot be read by hackers & challengers (browser)
            P ->> P: write 1P üç™<br/>ID & preferences
            P -->> B: display pageP.html
        deactivate P

        B -->> U:  

    deactivate U

end

rect rgba(255, 255, 255, .55)
    note right of U: Time T2<br>"READ" scenario: user visits a "new" advertiser without CMP

    U ->> B: visit www.advertiserA.com/pageA.html
    activate U

        activate B
            B ->> A: GET /pageA.html
        deactivate B

        activate A
            A ->> A: no Prebid SSO ID üç™ found
            A ->> A: build redirect URL
            A -->> B: REDIRECT
        deactivate A

        activate B
            B ->> O: call "read" endpoint<br/>redirectUrl = advertiserA.com/pageA.html
        deactivate B

        activate O
            note over B,O: make sure this URL cannot be "replayed" by hackers to read data
            O ->> O: read 1P üç™
            note over O: make sure<br/>advertiserA is authorized to read
            O -->> B: REDIRECT
        deactivate O

        activate B
            B ->> A: GET /pageA.html?<br/>cookie = ID & preferences
        deactivate B

        activate A
            note over B,A: make sure this URL cannot be "replayed" by hackers to write local cookies
            note over B,A: make sure ID & preferences in the URL<br/>cannot be read by hackers & challengers (browser)
            A ->> A: write 1P üç™
            A -->> B: display pageA.html
        deactivate A

        B -->> U: 

    deactivate U

end
```

## Designed protocol

This protocol:

‚úÖ reduces the server to server (S2S) calls to a minimum, making nodes more reliable.

‚úÖ is transparent to users and regulators (cookies and requests are human readable).

‚úÖ data received from the operator as a full page redirect can be processed by a web server **or in the browser**, in Javascript, because no decryption is needed.

‚úÖ protects from hackers' attempts:

- to read or write Prebid SSO data without being authenticated and authorized.

- to replay legit requests to the operator in an attempt to read or write Prebid SSO data or to websites to overwrite cookies on their domains (because of timestamp + signature).

- to replay legit URLs to overwrite cookies on *other* websites' domain (because the signature includes the receiver's domain name, it is tight to a specific receiver).

Limitations:

üü† operator needs to keep track of (potentially numerous) clients' public keys for signature verification

üü† data remains visible (or can be made visible) in URLs, so it can be used by web browser as part of the browsing history.

üü† it can also appear in web server logs.

```mermaid
sequenceDiagram
participant U as user
participant B as browser
participant P as publisher P http server
participant C as CMP http server
participant A as advertiser A http server
participant O as operator node O

rect rgba(224, 224, 224, .55)
    note right of U: Time T1<br>"WRITE" scenario: user visits publisher<br>and sets their preferences for the first time

    U ->> B: visit www.publisherP.com/pageP.html
    activate U

        activate B
            B ->> P: GET /pageP.html
        deactivate B

        activate P
            P -->> B: display
        deactivate P

        activate B
            B ->> B: JS: no Prebid SSO ID üç™ found
            B -->> C: JS call: GET prebidURL?pubPage=publisherP.com/pageP.html
        deactivate B

        activate C
            C ->> C: clear data = (timestamp<br>+ returnUrl=publisherP.com/pageP.html<br>+ sender=cmp.com)
            C ->> C: SIGN (clear data + receiver=operatorO.prebidsso.com)<br/> with own private key
            note over C: receiver is not part of the clear data
            C -->> B: "read prebid SSO" URL = ...
        deactivate C

        activate B
            B ->> B: JS: full page REDIRECT<br>(or wait for user click)
            B ->> O: GET /readOrInit?[...clear Data]&signature=xxx
        deactivate B

        activate O
            note over O: sender == cmp.com<br>key == cmp.com public key
            O ->> O: check cmp.com is allowed to read
            O ->> O: VERIFY full data signature<br/>with cmp.com public key
            note over O: cmp.com is authenticated<br/>and timestamp can be trusted
            O ->> O: check timestamp is still valid
            note over O: ok: this is a valid request
            O ->> O: no üç™ found
            O ->> O: create ID
            O ->> O: SIGN ID<br/>with own private key
            note over O: ID has been signed by operatorO.prebidsso.com<br/>it can be trusted
            O ->> O: clear data = (id + sign[id]<br>+ timestamp<br>+ sender=operatorO.prebidsso.com)
            O ->> O: SIGN (clear data + receiver=publisherP.com)<br/> with own private key
            O -->> B: REDIRECT
        deactivate O

        activate B
            B ->> P: GET /pageP.html&[...clear Data]&signature=xxx
        deactivate B

        activate P
            P -->> B: display
        deactivate P

        activate B
            note over B: sender == operatorO.prebidsso.com<br>key == operatorO.prebidsso.com public key
            B ->> B: VERIFY full data signature<br/>with operatorO.prebidsso.com public key
            note over B: operatorO.prebidsso.com is authenticated<br/>and timestamp can be trusted
            B ->> B: check timestamp is still valid
            note over B: ok: this is a valid request
            B ->> B: [optional] VERIFY sign[id]<br/>with operatorO.prebidsso.com public key
            B ->> B: JS: show id in form<br>or store in hidden input
            note over B: Note: don't write üç™ yet, wait for user consent
            B -->> U: 
        deactivate B

    deactivate U

    U ->> B: submit preferences

    activate U
        activate B
            B ->> C: JS call: GET /submitConsent?id=xxx&preferences=yyy
        deactivate B

        activate C
            C ->> C: SIGN (preferences + id)<br/>with own private key => sign[pref & id]
            note over C: signature includes id to ensure<br>these preferences are for this user.<br>It can be trusted
            C ->> C: clear data = (preferences + sign[pref & id]<br>+ timestamp<br>+ redirectUrl=publisherP.com/pageP.html + sender=cmp.com)
            C ->> C: SIGN (clear data + receiver=operatorO.prebidsso.com)<br/> with own private key
            C -->> B: "prebid SSO write URL" = ...
        deactivate C

        activate B
            B ->> B: JS: full page REDIRECT
            B ->> O: GET /writeAndRead?[...clear Data]&signature=xxx
        deactivate B

        activate O
            note over O: sender == cmp.com<br>key == cmp.com public key
            O ->> O: check cmp.com is allowed to read AND WRITE
            O ->> O: VERIFY full data signature<br/>with cmp.com public key
            note over O: cmp.com is authenticated<br/>and timestamp can be trusted
            O ->> O: check timestamp is in timeframe
            note over O: ok: this is a valid request
            O ->> O: read 1P üç™: ID & sign[id]
            O ->> O: VERIFY sign[pref & id]<br/>with cmp.com public key
            note over O: ok: these preferences are valid<br>and they are associated with the id
            O ->> O: write 1P üç™:<br/>preferences & sign[pref & id]
            note over O: preferences have been signed by cmp<br/>ID has been signed by operatorO.prebidsso.com<br/>both can be trusted
            O ->> O: clear data = (id + sign[id]<br>+ preferences + sign[pref & id]<br>+ timestamp<br>+ sender=operatorO.prebidsso.com)
            O ->> O: SIGN (clear data + receiver=publisherP.com)<br/> with own private key
            O -->> B: REDIRECT
        deactivate O

        activate B
            B ->> P: GET /pageP.html?[...clear Data]&signature=xxx
        deactivate B

        activate P
            P -->> B: display
        deactivate P

        activate B
            note over B: sender == operatorO.prebidsso.com<br>key == operatorO.prebidsso.com public key
            B ->> B: VERIFY full data signature<br/>with operatorO.prebidsso.com public key
            note over B: operatorO.prebidsso.com is authenticated<br/>and timestamp can be trusted
            B ->> B: check timestamp is in timeframe
            note over B: ok: this is a valid request
            B ->> B: VERIFY sign[id] with operatorO.prebidsso.com public key
            B ->> B: VERIFY sign[pref & id] with cmp.com public key
            B ->> B: write 1P üç™:<br/>id & sign[id]<br>preferences & sign[pref & id]
        deactivate B

        B -->> U: 

    deactivate U
end

rect rgba(255, 255, 255, .55)
    note right of U: Time T2<br>"READ" scenario: user visits a "new" advertiser

    U ->> B: visit www.advertiserA.com/pageA.html
    activate U

        activate B
            B ->> A: GET /pageA.html
        deactivate B

        activate A
        A ->> A: no üç™ found
        A ->> A: clear data = (timestamp<br>+ sender=advertiserA.com<br>+ returnUrl=advertiserA.com/pageA.html)
        A ->> A: SIGN (clear data + receiver=operatorO.prebidsso.com)<br/> with own private key
        A -->> B: REDIRECT
        deactivate A

        activate B
        B ->> O: GET or POST /read?[...clear Data]&signature=xxx
        deactivate B

        activate O
        note over O: sender == advertiserA.com<br>key == advertiserA.com public key
        O ->> O: check advertiserA.com is allowed to read
        O ->> O: VERIFY full data signature<br/>with advertiserA.com public key
        note over O: advertiserA is authenticated<br/>and timestamp can be trusted
        O ->> O: check timestamp is still valid
        note over O: ok: this is a valid request
        O ->> O: read 1P üç™:<br/>id & sign[id]<br>preferences & sign[pref & id]
        O ->> O: clear data = (id + sign[id]<br>+ preferences + sign[pref & id]<br>+ timestamp + sender=operatorO.prebidsso.com)
        O ->> O: SIGN (clear data + receiver=advertiserA.com)<br/> with own private key
        O -->> B: REDIRECT
        deactivate O 

        activate B
        B ->> A: GET /pageA.html?[...clear Data]&signature=xxx
        deactivate B

        activate A
        note over A: sender == operatorO.prebidsso.com<br>key == operatorO.prebidsso.com public key
        A ->> A: VERIFY full data signature<br/>with operatorO.prebidsso.com public key
        note over A: operatorO.prebidsso.com is authenticated<br/>and timestamp can be trusted
        A ->> A: check timestamp is in timeframe
        note over A: ok: this is a valid request
        A ->> A: VERIFY sign[id] with operatorO.prebidsso.com public key
        A ->> A: VERIFY sign[pref & id] with cmp.com public key
        A ->> A: write 1P üç™:<br/>id & sign[id]<br>preferences & sign[pref & id]
        A -->> B: display page
        deactivate A
        note over A: Note that this whole block can be done in the http server OR in the front end of publisher
        B -->> U: 

    deactivate U
end
```
